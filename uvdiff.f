C  do not edit this file, it was generated by ratty
c***********************************************************************
      program uvdiff
c
c= uvdiff -- Difference two visibility datasets.
c& rjs
c: uv analysis
c+
c       Given two Miriad visibility datasets, UVDIFF matches and
c       optionally subtracts one from the other.  In doing this, UVDIFF
c       assumes that the two datasets sample the same source using the
c       same array configuration and observing frequency setup (no
c       checks are made to verify these).  UVDIFF matches visibility
c       records based on baseline number, polarisation type and hour
c       angle.  If the hour angles in the two datasets do not match to
c       better than 1 second, UVDIFF linearly interpolates between two
c       integrations of one dataset to the appropriate hour angle of the
c       other.
c
c       NOTE: UVDIFF does not apply calibration corrections to either
c       of the input datasets.  The datasets should be in time order.
c@ vis
c       The two datasets to difference.  No default.  When differencing,
c       the output is the first minus the second.  The first visibility
c       dataset is used as the template for the output.  It is the
c       second dataset that is interpolated when needed.
c@ select
c       Standard visibility selection keyword.  See the help on "select"
c       for more information.  Note that this selection is applied ONLY
c       to the first visibility dataset.  The default is to select
c       everything.
c@ out
c       The output dataset.  No default.
c@ mode
c       This determines what data is written.  Possible values are:
c         difference Write the difference of the two inputs (the first
c                    minus the second).  This is the default.
c         two        Write the data from the second input, interpolated
c                    to the first.
c         one        Write the first dataset.
c       With the exception of the visibility data itself, all three
c       possibilities will produce identical datasets.  This includes
c       identical flagging information.
c       Any of these modes can be prefixed with a minus sign.  In this
c       case the output visibilities are negated.
c@ tol
c       Interpolation tolerance, in minutes.  This gives the maximum gap
c       between two integrations to interpolate across.  The default is
c       2 minutes.
c--
c  History:
c    04-jun-96 rjs  Preliminary version.
c    20-jun-96 rjs  Bring it up to scratch.
c    14-aug-96 rjs  Added ability to negate the output.
c    09-jul-04 jwr  Renamed Unpack to Unpck to avoid compiler
c                   complaining about unimplemented intrisics
c    24-jan-07 rjs  Default linetype.
c
c  Bugs/Shortcomings:
c    * Should handle the conjugate symmetry property, and match data
c      over a wider range of HA.
c
c $Id: uvdiff.for,v 1.5 2009/07/29 04:22:24 wright Exp $
c-----------------------------------------------------------------------
c >>> /opt/local/include/miriad-f/maxdim.h
c Warning: do not edit this file, it has been generated by configure
c TELESCOPE=ata
c=======================================================================
        CHARACTER*(*) MIRTEL
        PARAMETER(MIRTEL='ata')
        INTEGER   MAXBUF
        PARAMETER(MAXBUF=10000000)
c
        INTEGER   MAXDIM, MAXDIM2
        PARAMETER(MAXDIM=65536,MAXDIM2=8192)
c
        INTEGER   MAXIANT,MAXANT,MAXANT2
        PARAMETER(MAXIANT=2048,MAXANT=64,MAXANT2=28)
c		maximum number of baselines
        INTEGER   MAXBASE
c	PARAMETER(MAXBASE=((MAXANT*(MAXANT+1))/2))
        PARAMETER(MAXBASE=1058)
        INTEGER   MAXBASE2
        PARAMETER(MAXBASE2=1058)
c
        INTEGER   MAXCHAN
        PARAMETER(MAXCHAN=4096)
c
        INTEGER   MAXWIN
        PARAMETER(MAXWIN=16)
c
        INTEGER   MAXWIDE
        PARAMETER(MAXWIDE=18)
c=======================================================================
c
c <<< /opt/local/include/miriad-f/maxdim.h
c >>> /opt/local/include/miriad-f/mirconst.h
c=======================================================================
c - mirconst.h  Include file for various fundamental physical constants.
c
c  History:
c    jm  18dec90  Original code.  Constants taken from the paper
c                 "The Fundamental Physical Constants" by E. Richard
c                 Cohen and Barry N. Taylor (PHYICS TODAY, August 1989).
c   pjt  13aug08  Aligned with ATNF
c   pjt  14nov08  updated from latest NIST values
c                 http://physics.nist.gov/cuu/Constants/index.html
c
c $Id$
c ----------------------------------------------------------------------
c  Pi.
      double precision DPI, DPI_2, DPI_4, DTWOPI
      parameter (DPI = 3.14159265358979323846D0)
      parameter (DTWOPI = DPI * 2D0)
      parameter (DPI_2  = DPI / 2D0)
      parameter (DPI_4  = DPI / 4D0)
c
      real PI, PI_2, PI_4, TWOPI
      parameter (PI    = DPI)
      parameter (TWOPI = DTWOPI)
      parameter (PI_2  = DPI_2)
      parameter (PI_4  = DPI_4)
c ----------------------------------------------------------------------
c  Angular conversion factors.
      double precision DAS2R, DD2R, DR2AS, DR2D
      parameter (DD2R  =  DPI / 180D0)
      parameter (DR2D  =  1D0 / DD2R)
      parameter (DAS2R = DD2R / 3600D0)
      parameter (DR2AS =  1D0 / DAS2R)
c
      real AS2R, D2R, R2AS, R2D
      parameter (D2R   = DD2R)
      parameter (R2D   = DR2D)
      parameter (AS2R  = DAS2R)
      parameter (R2AS  = DR2AS)
c ----------------------------------------------------------------------
c  Speed of light (meter/second).
      double precision DCMKS
      parameter (DCMKS = 299792458D0)
c
      real CMKS
      parameter (CMKS = DCMKS)
c ----------------------------------------------------------------------
c  Boltzmann constant (Joule/Kelvin).
      double precision DKMKS
      parameter (DKMKS = 1.3806504D-23)
c
      real KMKS
      parameter (KMKS = DKMKS)
c ----------------------------------------------------------------------
c  Planck constant (Joule-second).
      double precision DHMKS
      parameter (DHMKS = 6.62606896D-34)
c
      real HMKS
      parameter (HMKS = DHMKS)
c ----------------------------------------------------------------------
c  Planck constant divided by Boltzmann constant (Kelvin/GHz).
      double precision DHOVERK
      parameter (DHOVERK = 1D9 * DHMKS / DKMKS)
c
      real HOVERK
      parameter (HOVERK = DHOVERK)
c=======================================================================
c <<< /opt/local/include/miriad-f/mirconst.h
c
      integer MAXSELS, NMODES
      parameter(MAXSELS=1000, NMODES=6)
c
      logical flags1(MAXCHAN), flags2(MAXCHAN), negate
      integer i, nchan, nout, npol, pol, tIn, tOut
      real    sels(MAXSELS), tol
      double precision lst, preamble(8)
      complex data1(MAXCHAN), data2(MAXCHAN)
      character ctemp*12, ltype*16, mode*12, modes(NMODES)*12, out*64,
     *          version*80, vis1*64, vis2*64
c
c     Externals.
      logical hdprsnt
      character versan*80
c
      data modes/'difference  ','one         ','two         ',
     *           '-difference ','-one        ','-two        '/
c-----------------------------------------------------------------------
      version = versan('uvdiff',
     *  '$Id: uvdiff.for,v 1.5 2009/07/29 04:22:24 wright Exp $')
c
c     Get the input parameters.
      call keyini
      call keya('vis',vis1,' ')
      call keya('vis',vis2,' ')
      call keya('out',out,' ')
      call keymatch('mode',NMODES,modes,1,mode,nout)
      if(nout.eq.0)mode = modes(1)
      negate = mode(1:1).eq.'-'
      if(negate)then
        ctemp = mode
        mode  = ctemp(2:)
      endif
      call keyr('tol',tol,2.0)
      call SelInput('select',sels,MAXSELS)
      call keyfin
      if(vis1.eq.' ' .or. vis2.eq.' ' .or. out.eq.' ')
     *  call bug('f','An input or output is missing')
      if(tol.le.0)call bug('f','Invalid interpolation tolerance')
      tol = tol * 2.0*PI/(24.0*60.0)
c
c     Open the inputs and outputs.
      call uvopen(tIn,vis1,'old')
      if(hdprsnt(tIn,'gains').or.hdprsnt(tIn,'leakage').or.
     *   hdprsnt(tIn,'bandpass'))then
        call bug('w',
     *    'Uvdiff does not apply pre-existing calibration tables')
        if(hdprsnt(tIn,'gains'))
     *    call bug('w','No antenna gain calibration applied')
        if(hdprsnt(tIn,'leakage'))
     *    call bug('w','No polarization calibration applied')
        if(hdprsnt(tIn,'bandpass'))
     *    call bug('w','No bandpass calibration applied')
      endif
c
      call uvset(tIn,'preamble','uvw/time/baseline/pol/ra/lst',
     *           0,0.,0.,0.)
      call SelApply(tIn,sels,.true.)
c
      call BInit(vis2)
      call getltype(tIn,ltype)
      call varInit(tIn,ltype)
      call uvopen(tOut,out,'new')
      call uvset(tOut,'preamble','uvw/time/baseline',0,0.,0.,0.)
      call hdcopy(tIn,tOut,'history')
      call hisopen(tOut,'append')
      call hiswrite(tOut,'UVDIFF: Miriad '//version)
      call hisinput(tOut,'UVDIFF')
      call hisclose(tOut)
      call varOnit(tIn,tOut,ltype)
c
c     Loop over all the data.
      call uvread(tIn,preamble,data1,flags1,MAXCHAN,nchan)
90000 if(nchan.gt.0)then
        call uvrdvri(tIn,'pol',pol,0)
        call uvrdvrd(tIn,'lst',lst,0.d0)
c
c       Get data from the second visibility dataset.
        call BGet(preamble(5),data2,flags2,nchan,tol)
c
c       Subtract if required.
        if(mode.eq.'one')then
          do 90001 i=1,nchan
            flags2(i) = flags1(i).and.flags2(i)
90001     continue
        else if(mode.eq.'two')then
          do 90002 i=1,nchan
            data1(i)  = data2(i)
            flags2(i) = flags1(i).and.flags2(i)
90002     continue
        else
          do 90003 i=1,nchan
            data1(i)  = data1(i) - data2(i)
            flags2(i) = flags1(i).and.flags2(i)
90003     continue
        endif
c
c       Negate if required.
        if(negate)then
          do 90004 i=1,nchan
            data1(i) = -data1(i)
90004     continue
        endif
c
        call varCopy(tIn,tOut)
        call uvrdvri(tIn,'npol',npol,0)
        call uvputvri(tOut,'pol',pol,1)
        call uvputvri(tOut,'npol',npol,1)
        call uvwrite(tOut,preamble,data1,flags2,nchan)
        call uvread(tIn,preamble,data1,flags1,MAXCHAN,nchan)
      goto 90000
      endif
c
      call uvclose(tIn)
      call uvclose(tOut)
      call BFin
c
      end
c***********************************************************************
      subroutine getltype(lIn,ltype)
c
      integer lIn
      character ltype*(*)
c
c     Determine the default line type.
c-----------------------------------------------------------------------
      logical update
      integer length
      character type*1
c
      call uvprobvr(lIn,'corr',type,length,update)
      if(type.eq.'j'.or.type.eq.'r'.or.type.eq.'c')then
        ltype = 'channel'
      else
        ltype = 'wide'
      endif
c
      end
c***********************************************************************
      subroutine BGet(vars1,data2,flags2,nchan1,tol)
c
      integer nchan1
      real tol
      double precision vars1(4)
      complex data2(nchan1)
      logical flags2(nchan1)
c
c  Generate the interpolated data.
c-----------------------------------------------------------------------
c >>> /opt/local/include/miriad-f/mirconst.h
c=======================================================================
c - mirconst.h  Include file for various fundamental physical constants.
c
c  History:
c    jm  18dec90  Original code.  Constants taken from the paper
c                 "The Fundamental Physical Constants" by E. Richard
c                 Cohen and Barry N. Taylor (PHYICS TODAY, August 1989).
c   pjt  13aug08  Aligned with ATNF
c   pjt  14nov08  updated from latest NIST values
c                 http://physics.nist.gov/cuu/Constants/index.html
c
c $Id$
c ----------------------------------------------------------------------
c  Pi.
      double precision DPI, DPI_2, DPI_4, DTWOPI
      parameter (DPI = 3.14159265358979323846D0)
      parameter (DTWOPI = DPI * 2D0)
      parameter (DPI_2  = DPI / 2D0)
      parameter (DPI_4  = DPI / 4D0)
c
      real PI, PI_2, PI_4, TWOPI
      parameter (PI    = DPI)
      parameter (TWOPI = DTWOPI)
      parameter (PI_2  = DPI_2)
      parameter (PI_4  = DPI_4)
c ----------------------------------------------------------------------
c  Angular conversion factors.
      double precision DAS2R, DD2R, DR2AS, DR2D
      parameter (DD2R  =  DPI / 180D0)
      parameter (DR2D  =  1D0 / DD2R)
      parameter (DAS2R = DD2R / 3600D0)
      parameter (DR2AS =  1D0 / DAS2R)
c
      real AS2R, D2R, R2AS, R2D
      parameter (D2R   = DD2R)
      parameter (R2D   = DR2D)
      parameter (AS2R  = DAS2R)
      parameter (R2AS  = DR2AS)
c ----------------------------------------------------------------------
c  Speed of light (meter/second).
      double precision DCMKS
      parameter (DCMKS = 299792458D0)
c
      real CMKS
      parameter (CMKS = DCMKS)
c ----------------------------------------------------------------------
c  Boltzmann constant (Joule/Kelvin).
      double precision DKMKS
      parameter (DKMKS = 1.3806504D-23)
c
      real KMKS
      parameter (KMKS = DKMKS)
c ----------------------------------------------------------------------
c  Planck constant (Joule-second).
      double precision DHMKS
      parameter (DHMKS = 6.62606896D-34)
c
      real HMKS
      parameter (HMKS = DHMKS)
c ----------------------------------------------------------------------
c  Planck constant divided by Boltzmann constant (Kelvin/GHz).
      double precision DHOVERK
      parameter (DHOVERK = 1D9 * DHMKS / DKMKS)
c
      real HOVERK
      parameter (HOVERK = DHOVERK)
c=======================================================================
c <<< /opt/local/include/miriad-f/mirconst.h
c >>> /Users/claw/code/mmm/claw/uvdiff.h
c >>> /opt/local/include/miriad-f/maxdim.h
c Warning: do not edit this file, it has been generated by configure
c TELESCOPE=ata
c=======================================================================
        CHARACTER*(*) MIRTEL
        PARAMETER(MIRTEL='ata')
        INTEGER   MAXBUF
        PARAMETER(MAXBUF=10000000)
c
        INTEGER   MAXDIM, MAXDIM2
        PARAMETER(MAXDIM=65536,MAXDIM2=8192)
c
        INTEGER   MAXIANT,MAXANT,MAXANT2
        PARAMETER(MAXIANT=2048,MAXANT=64,MAXANT2=28)
c		maximum number of baselines
        INTEGER   MAXBASE
c	PARAMETER(MAXBASE=((MAXANT*(MAXANT+1))/2))
        PARAMETER(MAXBASE=1058)
        INTEGER   MAXBASE2
        PARAMETER(MAXBASE2=1058)
c
        INTEGER   MAXCHAN
        PARAMETER(MAXCHAN=4096)
c
        INTEGER   MAXWIN
        PARAMETER(MAXWIN=16)
c
        INTEGER   MAXWIDE
        PARAMETER(MAXWIDE=18)
c=======================================================================
c
c <<< /opt/local/include/miriad-f/maxdim.h
c >>> /opt/local/include/miriad-f/mem.h
        real MemR(MAXBUF)
        integer MemI(MAXBUF)
        logical MemL(MAXBUF)
        double precision MemD(MAXBUF/2)
        complex MemC(MAXBUF/2)
        equivalence(MemR,MemI,MemL,MemD,MemC)
        common MemR
c <<< /opt/local/include/miriad-f/mem.h
c
      integer MAXPOL, POLMIN, POLMAX
      parameter (MAXPOL=4, POLMIN=-8, POLMAX=4)
c
      integer cindices(MAXPOL,MAXBASE,2), findices(MAXPOL,MAXBASE,2),
     *        iha, jha, nchan(2), npols, polindx(POLMIN:POLMAX), tno
      double precision ha2(2)
c
      common /uvdcom/ ha2, cindices, findices, iha, jha, nchan, npols,
     *                polindx, tno
c <<< /Users/claw/code/mmm/claw/uvdiff.h
c
      real mtol
      parameter(mtol = 2.0*PI/86400.0)
c
      logical oki, okj
      integer bl1, cidxi, cidxj, fidxi, fidxj, i, ipol1
      real    wi, wj
      double precision ha1
c
      call Unpck(vars1,ha1,bl1,ipol1)
c
c     Go through the dataset until we find the right integrations.
c     Note that in time-sorted, multi-day datasets, ha2(iha), the hour
c     angle for the older integration, may be greater than that for the
c     newer integration, ha2(jha).
90000 if(abs(ha1-ha2(iha)).gt.mtol .and.
     *        abs(ha1-ha2(jha)).gt.mtol .and.
     *       ((ha2(iha).le.ha2(jha) .and. ha1.gt.ha2(jha)) .or.
     *        (ha2(iha).gt.ha2(jha) .and. ha1.gt.ha2(jha))) .and.
     *        nchan(1).gt.0 .and.
     *        nchan(2).gt.0)then
        call Bload
      goto 90000
      endif
c
c     Cases of straight copy.
      cidxi = cindices(ipol1,bl1,iha)
      cidxj = cindices(ipol1,bl1,jha)
      fidxi = findices(ipol1,bl1,iha)
      fidxj = findices(ipol1,bl1,jha)
      oki = cidxi.ne.0 .and. fidxi.ne.0 .and. nchan1.eq.nchan(iha)
      okj = cidxj.ne.0 .and. fidxj.ne.0 .and. nchan1.eq.nchan(jha)
      cidxi = cidxi - 1
      cidxj = cidxj - 1
      fidxi = fidxi - 1
      fidxj = fidxj - 1
c
      if(oki .and. abs(ha1-ha2(iha)).lt.mtol)then
        do 90001 i=1,nchan1
          data2(i)  = Memc(cidxi+i)
          flags2(i) = Meml(fidxi+i)
90001   continue
      else if(okj .and. abs(ha1-ha2(jha)).lt.mtol)then
        do 90002 i=1,nchan1
          data2(i)  = Memc(cidxj+i)
          flags2(i) = Meml(fidxj+i)
90002   continue
c
      else if(oki .and. okj .and.
     *  (ha1-ha2(iha))*(ha2(jha)-ha1).ge.0.0 .and.
     *   abs(ha2(jha)-ha2(iha)).le.tol)then
c       Interpolate linearly between the two now.
        wi = 1.0 - abs((ha1-ha2(iha))/(ha2(jha)-ha2(iha)))
        wj = 1.0 - abs((ha1-ha2(jha))/(ha2(jha)-ha2(iha)))
        do 90003 i=1,nchan1
          data2(i)  = wi*Memc(cidxi+i) + wj*Memc(cidxj+i)
          flags2(i) = Meml(fidxi+i).and.Meml(fidxj+i)
90003   continue
c
      else
c       Case of it all failing.
        do 90004 i=1,nchan1
          data2(i)  = (0.0,0.0)
          flags2(i) = .false.
90004   continue
      endif
c
      end
c***********************************************************************
      subroutine unpck(vars,ha,bl,ipol)
c
      integer bl,ipol
      double precision ha, vars(4)
c
c  Unpck variables, in the order baseline,pol,ra,lst
c-----------------------------------------------------------------------
c >>> /opt/local/include/miriad-f/mirconst.h
c=======================================================================
c - mirconst.h  Include file for various fundamental physical constants.
c
c  History:
c    jm  18dec90  Original code.  Constants taken from the paper
c                 "The Fundamental Physical Constants" by E. Richard
c                 Cohen and Barry N. Taylor (PHYICS TODAY, August 1989).
c   pjt  13aug08  Aligned with ATNF
c   pjt  14nov08  updated from latest NIST values
c                 http://physics.nist.gov/cuu/Constants/index.html
c
c $Id$
c ----------------------------------------------------------------------
c  Pi.
      double precision DPI, DPI_2, DPI_4, DTWOPI
      parameter (DPI = 3.14159265358979323846D0)
      parameter (DTWOPI = DPI * 2D0)
      parameter (DPI_2  = DPI / 2D0)
      parameter (DPI_4  = DPI / 4D0)
c
      real PI, PI_2, PI_4, TWOPI
      parameter (PI    = DPI)
      parameter (TWOPI = DTWOPI)
      parameter (PI_2  = DPI_2)
      parameter (PI_4  = DPI_4)
c ----------------------------------------------------------------------
c  Angular conversion factors.
      double precision DAS2R, DD2R, DR2AS, DR2D
      parameter (DD2R  =  DPI / 180D0)
      parameter (DR2D  =  1D0 / DD2R)
      parameter (DAS2R = DD2R / 3600D0)
      parameter (DR2AS =  1D0 / DAS2R)
c
      real AS2R, D2R, R2AS, R2D
      parameter (D2R   = DD2R)
      parameter (R2D   = DR2D)
      parameter (AS2R  = DAS2R)
      parameter (R2AS  = DR2AS)
c ----------------------------------------------------------------------
c  Speed of light (meter/second).
      double precision DCMKS
      parameter (DCMKS = 299792458D0)
c
      real CMKS
      parameter (CMKS = DCMKS)
c ----------------------------------------------------------------------
c  Boltzmann constant (Joule/Kelvin).
      double precision DKMKS
      parameter (DKMKS = 1.3806504D-23)
c
      real KMKS
      parameter (KMKS = DKMKS)
c ----------------------------------------------------------------------
c  Planck constant (Joule-second).
      double precision DHMKS
      parameter (DHMKS = 6.62606896D-34)
c
      real HMKS
      parameter (HMKS = DHMKS)
c ----------------------------------------------------------------------
c  Planck constant divided by Boltzmann constant (Kelvin/GHz).
      double precision DHOVERK
      parameter (DHOVERK = 1D9 * DHMKS / DKMKS)
c
      real HOVERK
      parameter (HOVERK = DHOVERK)
c=======================================================================
c <<< /opt/local/include/miriad-f/mirconst.h
c >>> /Users/claw/code/mmm/claw/uvdiff.h
c >>> /opt/local/include/miriad-f/maxdim.h
c Warning: do not edit this file, it has been generated by configure
c TELESCOPE=ata
c=======================================================================
        CHARACTER*(*) MIRTEL
        PARAMETER(MIRTEL='ata')
        INTEGER   MAXBUF
        PARAMETER(MAXBUF=10000000)
c
        INTEGER   MAXDIM, MAXDIM2
        PARAMETER(MAXDIM=65536,MAXDIM2=8192)
c
        INTEGER   MAXIANT,MAXANT,MAXANT2
        PARAMETER(MAXIANT=2048,MAXANT=64,MAXANT2=28)
c		maximum number of baselines
        INTEGER   MAXBASE
c	PARAMETER(MAXBASE=((MAXANT*(MAXANT+1))/2))
        PARAMETER(MAXBASE=1058)
        INTEGER   MAXBASE2
        PARAMETER(MAXBASE2=1058)
c
        INTEGER   MAXCHAN
        PARAMETER(MAXCHAN=4096)
c
        INTEGER   MAXWIN
        PARAMETER(MAXWIN=16)
c
        INTEGER   MAXWIDE
        PARAMETER(MAXWIDE=18)
c=======================================================================
c
c <<< /opt/local/include/miriad-f/maxdim.h
c >>> /opt/local/include/miriad-f/mem.h
        real MemR(MAXBUF)
        integer MemI(MAXBUF)
        logical MemL(MAXBUF)
        double precision MemD(MAXBUF/2)
        complex MemC(MAXBUF/2)
        equivalence(MemR,MemI,MemL,MemD,MemC)
        common MemR
c <<< /opt/local/include/miriad-f/mem.h
c
      integer MAXPOL, POLMIN, POLMAX
      parameter (MAXPOL=4, POLMIN=-8, POLMAX=4)
c
      integer cindices(MAXPOL,MAXBASE,2), findices(MAXPOL,MAXBASE,2),
     *        iha, jha, nchan(2), npols, polindx(POLMIN:POLMAX), tno
      double precision ha2(2)
c
      common /uvdcom/ ha2, cindices, findices, iha, jha, nchan, npols,
     *                polindx, tno
c <<< /Users/claw/code/mmm/claw/uvdiff.h
      integer i1,i2
c
      ipol = -nint(vars(2)) - 4
      if(ipol.lt.POLMIN .or. ipol.gt.POLMAX)
     *  call bug('f','Invalid polarisation type')
      if(polindx(ipol).eq.0)then
        npols = npols + 1
        if(npols.gt.MAXPOL)call bug('f','Too many polarisations')
        polindx(ipol) = npols
      endif
      ipol = polindx(ipol)
c
      call Basant(vars(1),i1,i2)
      bl = ((i2-1)*i2)/2 + i1
      ha = mod(vars(4)-vars(3), 2d0*DPI)
      if(ha.gt.DPI)then
        ha = ha - 2.d0*DPI
      else if(ha.lt.-DPI)then
        ha = ha + 2*DPI
      endif
c
      end
c***********************************************************************
      subroutine BFin
c
c-----------------------------------------------------------------------
c >>> /Users/claw/code/mmm/claw/uvdiff.h
c >>> /opt/local/include/miriad-f/maxdim.h
c Warning: do not edit this file, it has been generated by configure
c TELESCOPE=ata
c=======================================================================
        CHARACTER*(*) MIRTEL
        PARAMETER(MIRTEL='ata')
        INTEGER   MAXBUF
        PARAMETER(MAXBUF=10000000)
c
        INTEGER   MAXDIM, MAXDIM2
        PARAMETER(MAXDIM=65536,MAXDIM2=8192)
c
        INTEGER   MAXIANT,MAXANT,MAXANT2
        PARAMETER(MAXIANT=2048,MAXANT=64,MAXANT2=28)
c		maximum number of baselines
        INTEGER   MAXBASE
c	PARAMETER(MAXBASE=((MAXANT*(MAXANT+1))/2))
        PARAMETER(MAXBASE=1058)
        INTEGER   MAXBASE2
        PARAMETER(MAXBASE2=1058)
c
        INTEGER   MAXCHAN
        PARAMETER(MAXCHAN=4096)
c
        INTEGER   MAXWIN
        PARAMETER(MAXWIN=16)
c
        INTEGER   MAXWIDE
        PARAMETER(MAXWIDE=18)
c=======================================================================
c
c <<< /opt/local/include/miriad-f/maxdim.h
c >>> /opt/local/include/miriad-f/mem.h
        real MemR(MAXBUF)
        integer MemI(MAXBUF)
        logical MemL(MAXBUF)
        double precision MemD(MAXBUF/2)
        complex MemC(MAXBUF/2)
        equivalence(MemR,MemI,MemL,MemD,MemC)
        common MemR
c <<< /opt/local/include/miriad-f/mem.h
c
      integer MAXPOL, POLMIN, POLMAX
      parameter (MAXPOL=4, POLMIN=-8, POLMAX=4)
c
      integer cindices(MAXPOL,MAXBASE,2), findices(MAXPOL,MAXBASE,2),
     *        iha, jha, nchan(2), npols, polindx(POLMIN:POLMAX), tno
      double precision ha2(2)
c
      common /uvdcom/ ha2, cindices, findices, iha, jha, nchan, npols,
     *                polindx, tno
c <<< /Users/claw/code/mmm/claw/uvdiff.h
      call uvclose(tno)
      end
c***********************************************************************
      subroutine BInit(vis)
c
      character vis*(*)
c-----------------------------------------------------------------------
c >>> /Users/claw/code/mmm/claw/uvdiff.h
c >>> /opt/local/include/miriad-f/maxdim.h
c Warning: do not edit this file, it has been generated by configure
c TELESCOPE=ata
c=======================================================================
        CHARACTER*(*) MIRTEL
        PARAMETER(MIRTEL='ata')
        INTEGER   MAXBUF
        PARAMETER(MAXBUF=10000000)
c
        INTEGER   MAXDIM, MAXDIM2
        PARAMETER(MAXDIM=65536,MAXDIM2=8192)
c
        INTEGER   MAXIANT,MAXANT,MAXANT2
        PARAMETER(MAXIANT=2048,MAXANT=64,MAXANT2=28)
c		maximum number of baselines
        INTEGER   MAXBASE
c	PARAMETER(MAXBASE=((MAXANT*(MAXANT+1))/2))
        PARAMETER(MAXBASE=1058)
        INTEGER   MAXBASE2
        PARAMETER(MAXBASE2=1058)
c
        INTEGER   MAXCHAN
        PARAMETER(MAXCHAN=4096)
c
        INTEGER   MAXWIN
        PARAMETER(MAXWIN=16)
c
        INTEGER   MAXWIDE
        PARAMETER(MAXWIDE=18)
c=======================================================================
c
c <<< /opt/local/include/miriad-f/maxdim.h
c >>> /opt/local/include/miriad-f/mem.h
        real MemR(MAXBUF)
        integer MemI(MAXBUF)
        logical MemL(MAXBUF)
        double precision MemD(MAXBUF/2)
        complex MemC(MAXBUF/2)
        equivalence(MemR,MemI,MemL,MemD,MemC)
        common MemR
c <<< /opt/local/include/miriad-f/mem.h
c
      integer MAXPOL, POLMIN, POLMAX
      parameter (MAXPOL=4, POLMIN=-8, POLMAX=4)
c
      integer cindices(MAXPOL,MAXBASE,2), findices(MAXPOL,MAXBASE,2),
     *        iha, jha, nchan(2), npols, polindx(POLMIN:POLMAX), tno
      double precision ha2(2)
c
      common /uvdcom/ ha2, cindices, findices, iha, jha, nchan, npols,
     *                polindx, tno
c <<< /Users/claw/code/mmm/claw/uvdiff.h
      integer i
c
c     Externals.
      logical hdprsnt
c
c     Open the second dataset.
      call uvopen(tno,vis,'old')
      if(hdprsnt(tno,'gains')   .or.
     *   hdprsnt(tno,'leakage') .or.
     *   hdprsnt(tno,'bandpass'))then
        call bug('w',
     *    'Uvdiff does not apply pre-existing calibration tables')
        if(hdprsnt(tno,'gains'))
     *    call bug('w','No antenna gain calibration applied')
        if(hdprsnt(tno,'leakage'))
     *    call bug('w','No polarization calibration applied')
        if(hdprsnt(tno,'bandpass'))
     *    call bug('w','No bandpass calibration applied')
      endif
c
      call uvset(tno,'preamble','baseline/pol/ra/lst',0,0.,0.,0.)
c
      npols = 0
      do 90000 i = POLMIN, POLMAX
        polindx(i) = 0
90000 continue
c
      jha = 0
      call BLoad
      call BLoad
c      if(nchan(1).eq.0 .or. nchan(2).eq.0)
c     *        call bug('w','No integrations found')
      end
c***********************************************************************
      subroutine Bload
c
c  Load the next integration.
c-----------------------------------------------------------------------
c >>> /Users/claw/code/mmm/claw/uvdiff.h
c >>> /opt/local/include/miriad-f/maxdim.h
c Warning: do not edit this file, it has been generated by configure
c TELESCOPE=ata
c=======================================================================
        CHARACTER*(*) MIRTEL
        PARAMETER(MIRTEL='ata')
        INTEGER   MAXBUF
        PARAMETER(MAXBUF=10000000)
c
        INTEGER   MAXDIM, MAXDIM2
        PARAMETER(MAXDIM=65536,MAXDIM2=8192)
c
        INTEGER   MAXIANT,MAXANT,MAXANT2
        PARAMETER(MAXIANT=2048,MAXANT=64,MAXANT2=28)
c		maximum number of baselines
        INTEGER   MAXBASE
c	PARAMETER(MAXBASE=((MAXANT*(MAXANT+1))/2))
        PARAMETER(MAXBASE=1058)
        INTEGER   MAXBASE2
        PARAMETER(MAXBASE2=1058)
c
        INTEGER   MAXCHAN
        PARAMETER(MAXCHAN=4096)
c
        INTEGER   MAXWIN
        PARAMETER(MAXWIN=16)
c
        INTEGER   MAXWIDE
        PARAMETER(MAXWIDE=18)
c=======================================================================
c
c <<< /opt/local/include/miriad-f/maxdim.h
c >>> /opt/local/include/miriad-f/mem.h
        real MemR(MAXBUF)
        integer MemI(MAXBUF)
        logical MemL(MAXBUF)
        double precision MemD(MAXBUF/2)
        complex MemC(MAXBUF/2)
        equivalence(MemR,MemI,MemL,MemD,MemC)
        common MemR
c <<< /opt/local/include/miriad-f/mem.h
c
      integer MAXPOL, POLMIN, POLMAX
      parameter (MAXPOL=4, POLMIN=-8, POLMAX=4)
c
      integer cindices(MAXPOL,MAXBASE,2), findices(MAXPOL,MAXBASE,2),
     *        iha, jha, nchan(2), npols, polindx(POLMIN:POLMAX), tno
      double precision ha2(2)
c
      common /uvdcom/ ha2, cindices, findices, iha, jha, nchan, npols,
     *                polindx, tno
c <<< /Users/claw/code/mmm/claw/uvdiff.h
c
      logical lspare(MAXCHAN)
      integer base(2), cidx, fidx, i, ibase, ipol, nspare, pol(2)
      double precision ha, pspare(4)
      complex cspare(MAXCHAN)
c
      save base, pol
      save cspare, lspare, nspare, pspare
c
      if (jha.eq.0) then
c       Initialize indexes.
        do 90000 jha = 1, 2
          do 90001 ibase = 1, MAXBASE
            do 90002 ipol = 1, MAXPOL
              cindices(ipol,ibase,jha) = 0
              findices(ipol,ibase,jha) = 0
90002       continue
90001     continue
c
          pol(jha)  = 0
          base(jha) = 0
90000   continue
c
        jha = 2
c
c       Load the spare buffer.
        nchan(1) = 1
        nchan(2) = 1
        call uvread(tno,pspare,cspare,lspare,MAXCHAN,nspare)
      end if
c
c     Switch buffers.
      iha = jha
      jha = 1 + mod(jha,2)
c
c     Clear the target buffer.
      do 90003 ibase=1,base(jha)
        do 90004 ipol=1,pol(jha)
          if(cindices(ipol,ibase,jha).gt.0)
     *      call memFree(cindices(ipol,ibase,jha),nchan(jha),'c')
          if(findices(ipol,ibase,jha).gt.0)
     *      call memFree(findices(ipol,ibase,jha),nchan(jha),'l')
          cindices(ipol,ibase,jha) = 0
          findices(ipol,ibase,jha) = 0
90004   continue
90003 continue
      base(jha) = 0
      pol(jha)  = 0
c
c     Determine the polarisation and hour angle of the spare record.
      nchan(jha) = nspare
      if(nchan(1).le.0 .or. nchan(2).le.0)return
      call unpck(pspare,ha,ibase,ipol)
      ha2(jha) = ha
c
90005 if(abs(ha-ha2(jha)).lt.1e-4 .and. nspare.eq.nchan(jha))then
c       Which output slot does the current record fall into?
        if(cindices(ipol,ibase,jha).gt.0.or.
     *     findices(ipol,ibase,jha).gt.0)call bug('w',
     *    'Multiple records for the same baseline within integration')
        call memAlloc(cindices(ipol,ibase,jha),nchan(jha),'c')
        call memAlloc(findices(ipol,ibase,jha),nchan(jha),'l')
        cidx = cindices(ipol,ibase,jha) - 1
        fidx = findices(ipol,ibase,jha) - 1
        do 90006 i=1,nspare
          Memc(cidx+i) = cspare(i)
          Meml(fidx+i) = lspare(i)
90006   continue
c
        base(jha) = max(base(jha),ibase)
        pol(jha)  = max(pol(jha), ipol)
c
c       Get another record.
        call uvread(tno,pspare,cspare,lspare,MAXCHAN,nspare)
        if(nspare.gt.0)call unpck(pspare,ha,ibase,ipol)
      goto 90005
      endif
c
      if(abs(ha-ha2(jha)).lt.1e-4 .and. nspare.ne.0)
     *  call bug('f','Number of channels changed within an integration')
c
      end
C  do not edit this file, it was generated by ratty
